<div id="documentation-container">
    <h3>Overview</h3>
    <p>Punk is a weakly typed Interpreted programming language for doing data analysis, mathematics, mathematics graphing, and stock market data pulls and building probability models. 
    </p>

    <h3 id="DocBaseTypes"><strong>Base Types</strong></h3>
    <h4><strong>Number Type</strong></h4>
    <p>Internally, represents a double or long. To declare a number variable is as simple as :</p>
    <p>        x = 5 or x = 4.5</p>
    <p>Internally Punk figures out the type on it's own, no need to declare the type</p>

    <h4><strong>Data Type</strong></h4>
    <p>Data type is an array style type. It's purpose is to store a collection of numbers. For example:</p> 
    <p>         [1.5<span class="bold">,</span> 2<span class="bold">,</span>40.0] </p>
    <p>is a datatype. Another way to initialize a Data type is to create an interval: </p>
    <p>         [-10<span class="bold">...</span>10]</p>
    <p></p>
    <h3 id="DocOperators"><strong>Base Operations </strong></h3>
    <p><span class="color-blue bold">+</span>   Addition operator: adds two values together </p>
    <p><span class="color-blue bold">-</span>   Subtraction Operator: subtracts two values or negates a positive number</p>
    <p><span class="color-blue bold">*</span>   Multiplication Operator : Multiplies two values together</p>
    <p><span class="color-blue bold">/</span>   Division Operator: divides two values. Please note if your numerator and demoninator are both integers, it will be integer division.</p>
    <p><span class="color-blue bold">|</span>   Pipe Operator : This operator takes output from the left operand and pushes it into the right. See integration below </p>
    <p><span class="color-blue bold">.</span>   Instance Function Operator : Calls functions of types. if x is a matrix, X.transpose() is an exmaple of an instance function of the matrix type</p>
    <p><span class="color-blue bold">=</span>   Assignment Operator : assigns a variable</p>
    <p><span class="color-blue bold">&</span>   Modulus Operator : returns remainder of a division</p>

    <h3 id="DocMatrices"><strong>Matrices </strong></h3>
    <p>To declare a matrix you use the following syntax:</p>
    <p class="code">x = ||10 12 7; 2 5 7; ||</p>
    <p>This creates a 2 row matrix with <span class="bold">10, 12, 7</span> in the first row and <span class="bold">2, 5, 7</span> in the second row </p>
    <p>The following operators are implemented:  <span class="bold">+</span> , <span class="bold">-</span>, <span class="bold">*</span>, <span class="bold">/</span> and <span class="bold">%</span>  </p>
    <h4>Matrix Instance Functions</h4>
     <p><span class="bold">transpose</span> : <span class="code">x = ||10 12 7; 2 5 7; || ===> x.Transpose() or x = ||10 12 7; 2 5 7; ||.transpose() </span></p>
     <p><span class="bold">inverse</span> : <span class="code">x = ||10 12 7; 2 5 7; || ===> x.inverse() or x = ||10 12 7; 2 5 7; ||.inverse() </span></p>
     <p><span class="bold">determinant</span> : <span class="code">x = ||10 12 7; 2 5 7; || ===> x.determinant() or x = ||10 12 7; 2 5 7; ||.determinant()</span> </p>
     <p><span class="bold">kernel</span> :<span class="code"> x = ||10 12 7; 2 5 7; || ===> x.kernel() or x = ||10 12 7; 2 5 7; ||.kernel() </span></p>
     <p><span class="bold">column</span> :<span class="code">x = ||10 12 7; 2 5 7; || ===> x.column(0) or x = ||10 12 7; 2 5 7; ||.column(0)  returns Column Vector [10, 2] </span></p>
     <p><span class="bold">transposethismultiply</span>: <span class="code">x = ||10 12 7; 2 5 7; || ===> x.transposethismultiply(y) where y is a matrix,  transpose x and multiplied it with y </span></p>
     <p><span class="bold">transposemultiply</span> :<span class="code">x = ||10 12 7; 2 5 7; || ===> x.transposemultiply(y) x multiplied by y transpose </span></p>
     <p><span class="bold">solve </span> : Cholesky decompose and then solve the equation </p>

    <h4 id="DocSequences"><strong>Sequence Operator</strong></h4>
    <p>Sequences have 2 classes. The first type of sequence are functions(or calculations) run on each piece of data, which  transforms the data. An example of such a sequence is:
    <p class="code"> x = [-10...10]{{'{'}}x0 : return Pow(x0,2);{{'}'}} =====> x = [100,81,<span>...</span>, 81,100]</p>
    <p>This sequence runs a power function on each element in the interval. The first part of the sequence(x0) represents the input(which is an element of the Data). and the second part(return) 
        specifies the calculation you want outputed followed by a semicolon(<span class="bold">;</span>).So in this example, we input each 21 elements in the interval -10...10 and square them. 
        This returns the sequence above. You can read more about the Pow function <a href="/documentation/DocMath">below</a>.
    </p> 
    <p> We could also declare 2 dimensional sequences. You can do this for contour or surface plotting or analysis. An example of this would be the following sequence: </p>
    <p class="code">          x = [-7...7,-7...7]{{'{'}}x0, x1 : return Sin(x0) + Cos(x1); {{'}'}}</p>
    <p>This produces a matrix of numbers of a surface. Which you can plot as a contour or 3d surface in the plot. </p>
    <p>We can also create indefinite sequences which serve as input to other sequences who take sequence input such as <a href="/documentation/DocIntegration">integration</a>. The syntax to do this is : </p>
    <p class="code">[ ] {{'{'}}x : return f(x);{{'}'}}</p>

    <h3 id='DocRegisters'><strong>Data Registers </strong></h3>
    <p>Data Registers are internal databases hosted within our applications ecosystem. You are able to query against them for information for helping to build your own probability models.</p>
    <p>To access a particular dataregister, your syntax should be as follows:</p>
    <p class="code">     ##stocks{{'{'}}QueryFunction{{'}'}} </p>
    <p>Here we access the register using ##stocks{{'{'}}.....{{'}'}}
    <h3>Current Registers:</h3>
    <h4>Stock Register:</h4>
    <p>This register pulls stock data. Fields are 'date', 'open', 'Low' 'close' 'adjclose' 'high' 'volume' 'ticker' </p>
    <!-- <h4>Options Register:</h4> -->
    <!-- <p>This register pulls option data. </p> -->

    <h4>Federal Reserve Register:</h4>
    <p>This register pulls economic data from the federal reserve</p>

    <h3 id="DocQueries"><strong>Queries </strong></h3>
    <p>Queries are search operations run on data registers to pull data for analysis. Queries are run on data registers</p>
    <h2>Stock Register Queries</h2>
    <p>GetPrices : Returns OHLCV prices for the specified Ticker <span class="code">##stocks{{'{'}}stocks.GetPrices(Symbol,StartDate(optional), EndDate(optional)){{'}'}}</span></p>
    <p>Example: <span class="code">##stocks{{'{'}}GetPrices("SPY","2020-01-03" ){{'}'}}</span> Returns all prices past 01/03/2020 </p>
    <p>Query : Returns OHLCV prices for the specified Query Expression <span class="code">##stocks{{'{'}}Query(var => expression(var)){{'}'}}</span></p>
    <p>Query Expressions are lambda expressions that return a true or false value(boolean). The following example ret urn alls closes above 120.0 for symbol XLY</p>
    <p class="code">##stocks{{'{'}}Query(x => x.Ticker == ""XLY"" && x.Close > 120.0){{'}'}}</p>
    <p>Try to make your query as specific as you can. Returning too much data will result in an error.</p>
    <p>In the preceeding query, I can name my variable whatever I want. In this case it was x, but I could have named it 'p' or 'y'. The naming is your choice</p>
    <p>Lead : Returns prices with Lead prices   <span class="code">##stocks{{'{'}}Lead("SPY",LookforwardFinancialDays ,start_date(optional), end_date(optional) ){{'}'}} </span> </p>
    <p>Example : <span class="code">##stocks{{'{'}}Lead("SPY",5 ,"2020-01-03" ){{'}'}}</span> Returns all prices past 01/03/2020 as well as the data 5 days into the future</p>
    <p>Lag : Returns prices with lag prices   <span class="code">##stocks{{'{'}}Lag("SPY",LookBackFinancialDays ,start_date(optional), end_date(optional) ){{'}'}} </span> </p>
    <p>Example : <span class="code">##stocks{{'{'}}Lag("SPY",5 ,"2020-01-03" ){{'}'}}</span> Returns all prices past 01/03/2020 as well as the data 5 days into the past(when available)</p>
    <p>EMA : returns Exponential moving average <span class="code">##stocks{{'{'}}stocks.EMA(Duration, Symbol ,start_date(optional), end_date(optional) ){{'}'}}</span> Returns the Exponential moving average for the specified duration for symbol</p>
    <p>Example : <span class="code">##stocks{{'{'}}EMA("SPY",20 ,"2020-01-03" ){{'}'}}</span> Returns the 20 day exponential moving average for SPY</p>
    <p>SMA : returns Simple moving average <span class="code">##stocks{{'{'}}SMA(Duration,Symbol ,start_date(optional), end_date(optional) ){{'}'}}</span> Returns the Simple moving average for the specified duration for the symbol</p>
    <p>Example : <span class="code">##stocks{{'{'}}SMA(20,"SPY" ,"2020-01-03" ){{'}'}}</span> Returns the 20 day exponential moving average for SPY</p>
    <h2>FRED Register queries</h2>
    <p>FRED is the nickname for the economic data published from the ST Luis FED. Series ID's and more data could be found on there website. </p>
    <p> Currently we support the following Series Id's. If you wish to request more economic data, please shoot us an email, we can see if we can accomadate it.</p>
    <p class="color-green">T10Y2Y, MORTGAGE30US,DHHNGSP,DGS3MO,DGS1,
        DGS2,DGS5,DGS10,DGS30,EXPINF2YR,WM2NS,
        RRPONTSYD,EFFR,WTISPLC,UNRATE,UNRATE,
        T10Y3M,NGDPSAXDCUSQ,CCLACBW027SBOG,SWPT</p>
    <p>In terms of the sequences supported, we support all the same sequences as the stock data register, with the exception of GetPrices. FRED data uses 'GetObservations', though the signature remains the same:</p>
    <p class="code">##fred{{'{'}}GetObservations("T10Y2Y","2023-01-01"){{'}'}}</p>

    <h3 id='DocFiles'><strong>Files</strong></h3>
    <p> We allow input of CSV files for processing. We parse them into a matrix with vectors that are the columns. To input csv files, you click the paperclick icon in the IDE and select your files. Our application will grab the files and parse them into matrixes you can use for 
        further calculations. Please note that we ignore any string fields and parse the data into 8 byte doubles, regardless even if it's an integer value. To use files in your Syntax Expressions  you reference them F0 for the first file, F1 for the second, the third as F2
        ....etc. This is an example of creating a normal equation using the files data
    </p>
    <p class="code">xr = F0.column(5) </p>
    <p class="code">ysolve = xr.transposethismultiply(F0)</p>
    <p class="code">weights = xr.transposethismultiply(xr).solve(ysolve)</p>
    <p class="code">yhats = xr * weights

    <h3 id="DocProbability"><strong>Probability</strong></h3>
    <p>The following distributions can be declared and used. For the discrete distributions, you have the probability at point k available as well as the cdf. For the continuous distributions, there is the probability at points
        so we have the cdf. You can declare a distribution the following way:
    </p>
    <p class="code"> x = Binomial(0.6, 20)</p>
    <p>This declares a binomial distribution with 0.6 probability of success and 20 trials. To get the probability of the distribution at point 2:</p>
    <p class="code"> p = x.probability(2)</p>
    <h2>   Discrete Distributions:</h2>
    <p>   Uniform(<span class="color-blue">int</span> lower, <span class="color-blue">int</span>  upper) (Discrete)</p>
    <p>   Bernoulli(<span class="color-primary500">double</span> probability) </p>
    <p>   Binomial(<span class="color-primary500">double</span> probability, <span class="color-blue">int</span>  number of trials) </p>
    <p>   Negative Binomial(<span class="color-primary500">double</span> r, <span class="color-primary500">double</span> p) -> models N </p>
    <p>   Geometric(<span class="color-primary500">double</span> p) </p>
    <p>   Hypergeometric(<span class="color-blue">int</span>  population , <span class="color-blue">int</span>  sucess, <span class="color-blue">int</span>  draws) </p>
    <p>   Poisson(<span class="color-primary500">double</span> lambda) </p>
    <p>   Categorical(<span class="color-primary500">double</span>[] probability mass) </p>
    <p>   Conway-Maxwell-Poisson(<span class="color-primary500">double</span> lambda, <span class="color-primary500">double</span> mu) </p>
    <p>   Zipf(<span class="color-primary500">double</span> s, <span class="color-blue">int</span>  n) </p>

    <p></p>
    <p><strong>Continuous Distributions:</strong></p>
    <p>   Uniform(<span class="color-primary500">double</span> lower, <span class="color-primary500">double</span> upper) (continuous)
    <p>   Normal(<span class="color-primary500">double</span> optional:mean, <span class="color-primary500">double</span>optional: standard deviation) ** defaults to 0 mean and 1 variance</p>
    <p>   Log Normal(<span class="color-primary500">double</span> mu, <span class="color-primary500">double</span> sigma)</p>
    <p>   Beta(<span class="color-primary500">double</span> a, <span class="color-primary500">double</span> b)</p>
    <p>   Cauchy(<span class="color-primary500">double</span> location, <span class="color-primary500">double</span> scale)</p>
    <p>   Chi(<span class="color-primary500">double</span> freedom)</p>
    <p>   Chi Squared(<span class="color-primary500">double</span> freedom)</p>
    <p>   Erlang(int shape, <span class="color-primary500">double</span> rate)</p>
    <p>   Exponential(<span class="color-primary500">double</span> rate)</p>
    <p>   Fisher-Snedecor (F-Distribution)(<span class="color-primary500">double</span> d1, <span class="color-primary500">double</span> d2)</p>
    <p>   Gamma(<span class="color-primary500">double</span> shape, <span class="color-primary500">double</span> rate)</p>
    <p>   Inverse Gamma(<span class="color-primary500">double</span> shape, <span class="color-primary500">double</span> scale)</p>
    <p>   Laplace(<span class="color-primary500">double</span> location, <span class="color-primary500">double</span> scale)</p>
    <p>   Pareto(<span class="color-primary500">double</span> scale, <span class="color-primary500">double</span> shape)</p>
    <p>   Rayleigh(<span class="color-primary500">double</span> scale)</p>
    <p>   Stable(<span class="color-primary500">double</span> alpha, <span class="color-primary500">double</span> beta, <span class="color-primary500">double</span> scale, <span class="color-primary500">double</span> location)</p>
    <p>   Student-T(<span class="color-primary500">double</span> location, <span class="color-primary500">double</span> scale, <span class="color-primary500">double</span> freedom)</p>
    <p>   Weibull(<span class="color-primary500">double</span> shape, <span class="color-primary500">double</span> scale)</p>
    <p>   Triangular(<span class="color-primary500">double</span> lower, <span class="color-primary500">double</span> upper, <span class="color-primary500">double</span> mode)</p>
    <p>   For any of the following distributions, we will allow sampling from the distribution. To do so you need to pipe data into the distribution:</p>

    <p class="code">d = binomial(0.5, 10)</p>
    <p class="code">[1...10] | d</p>
    <p>This code declares a binomial distribution with p = 0.5 and n = 10. We then randomly sample the distribution 10 times(one for every element in the data array). The expression returns a data array with all the samples</p>
    <p> Each probability distribution has a sample function. </p>

    <p></p>
    <h3 id="DocIntegration"><strong>Integration</strong></h3>
    <p>Integration is the process of finding areas under curves. We have a couple of procedures to integrate functions. The general procedure for integrating functions using Punk is to pipe in a sequence and pass it into another sequence 
        which integrates it. The syntax looks like this(for SimpsonRule.IntegrateComposite) : <p>
    <p class="code">SimpsonRule.IntegrateComposite(<span class="color-green bold">x</span> <span class="color-blue bold">=></span> <span class="italics bold">fn(x)</span>, 0.0, 10.0, 4); </p>
    <p class="code">NewtonCotesTrapeziumRule.IntegrateAdaptive(<span class="color-green bold">x</span> <span class="color-blue bold">=></span> <span class="italics bold">fn(x)</span>, 0.0, 10.0, <span class="color-red">1e-5</span>); </p>
    <p class ="code">DoubleExponentialTransformation.Integrate(<span class="color-green bold">x</span> <span class="color-blue bold">=></span> <span class="italics bold">fn(x)</span>, 0.0, 10.0, <span class="color-red">1e-5</span>);</p>
    
    <p> For example the following code shows how to integrate using SimpsonRule.Integrate Composite: </p>
    <p><span class="code">[</span><span class="color-green">]</span> {{'{'}}x0 : return Pow(x0,2);{{'}'}} | <span class="color-green">[</span> <span class="color-green">]</span>{{'{'}}fn: return SimpsonRule.IntegrateComposite(x => fn(x), 0.0, 10.0, 4);{{'}'}}</p>
    <p>Here we use the pipe operator "|" to pass the function into the integration sequence above. You can think of pipe operators as a flow, it's job is to push a value into the object on the right. The integration sequence expects a 
        function (fn). The rest of the arguments are the range(0.0 - 10.0) and the partitions for IntegrateComposite. Other integration functions expect a solve solution precision. (1e -5 ) for example, is solving for 1/100000 precision.
    </p>

    <h3 id="DocMath"> Common Math functions</h3>
    <p>We provide a list of common mathematical operators.</p>
    <p>Cos(<span class="color-primary500">double</span> x) : returns the Cosine of a value x</p>
    <p>Sin(<span class="color-primary500">double</span> x) : returns the Sin of a value</p>
    <p>Tan(<span class="color-primary500">double</span> x) : returns the Tan of x</p>
    <p>Pow(<span class="color-primary500">double</span> x, <span class="color-primary500">double</span> y) : raised x to the yth power. Both x and y are doubles</p>
    <p>Sqrt(<span class="color-primary500">double</span> x) : returns the square root of x</p>
    <p>Exp(<span class="color-primary500">double</span> x) : raised e to the xth power</p>
    <p>Log(<span class="color-primary500">double</span> x) : returns the natural log of x</p>
    <p>Floor(<span class="color-primary500">double</span> x) : returns the next integer down from x</p>
    <p>Ceiling(<span class="color-primary500">double</span> x) returns the next integer up from x</p>
    <p>Round(<span class="color-primary500">double</span> x,<span class="color-primary500">double</span> y) : Rounds x to y places</p>
    <p>Truncate(<span class="color-primary500">double</span> x) : slices the decimals off and returns the integer part</p>
    <p>Abs(<span class="color-primary500">double</span> x) : returns the absolute value of the number x</p>

    <h3 id="DocPlotting"> <strong>Plotting</strong></h3>
    <p>Plotting functions can be done from the IDE. In order to plot, you must create an expression using our language. Any Queries or data types can be plotted within the Graphing Utility
    </p>
    <h3>Traces</h3>
    <p>Traces are each contintiguous series of lines. For example, a candlestick chart of AMZN from 2022-01-01 - present would be a trace. </p>
    <p>Please check out some of the graphing utilities on the page</p>

</div>
